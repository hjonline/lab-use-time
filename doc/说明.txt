文档说明：
一、使用说明：
1 修改 g-1.ini 中的 1=>开学日期，
                   2=>节日（包括节日遇上周末后另外选定的日期），
		   3=>节日与周末交换的节假日
2 修改 g-1.ini 中的班级任课教师，每个班，每周课表，
3 根据学期，把这一学期的课题栏目去掉注释，而把另一个学期的课题都加上注释
4 运行时要加上  > lab-use-time/result/temp_result_1.txt
5 把 temp_result_1.txt 打开，复制其中内容到 word 文档，转换成表格，共 6 栏，复制
6 打开原来的实验室表格作为模板，修改标题的学期，选中原来的表格内容，并最好多选几行，把新的内容复制进去，最后可能会有多余的几行，要删掉，可能还要调整列宽，最好制作原来表格时，就不要固定列宽。


二、编程说明：
1 很多数组，hash 数组的名称，都是从配置文件 g-1.ini 里生成的，就是 “[]” 中的部分。并且，如果 “[]”中的部分，最后结尾是 _1 这样的数字的话，代表这些相同名称而结尾有编号的结构，都是一个大的结构的组成部分，例如 @class_week ，它代表每个班级，每个星期，可能有两节课，这样，每个班级的第一节课放在 $class_week[0] 里面，而第二节课，就在 $class_week[1] 里。

2 很多数组都是以 [年级][班级] 作为一个基本的二维结构，比如任课教师的安排表， @class_teachers 。

3 每个班级每周的课可以看成不同的线，比如三（5）班，周一有一节，周三有一节，这样到了下一周，又是这样两节，从纵向来看，有一条线从第一周一直向下，把每周的周一连在一起，另一条线，是把周三连在一起。那这样，我们有这样一个数组，外面的两维，是 [年级][班级]，对三（5）班来说就是 [2][4]，因为数组的计数，是从 0 开始的，然后在这个元素的里面，又有两个元素，[2][4][0] 是周一的课的日期，原始值是 1 ,[2][4][1] 是周三的课，所以原始值是 3 。
  当然，这个数组不存在，实际上起到这个数组的作用的就是 @class_week ，它的结构正好倒过来，最里面的一层在最外面，当然，效果是一样的。

4 上课安排的一个比较棘手的问题，是节日的存在，节日不仅包括法定的节日，还包括开学日可能不在一周的第一天，所以这一周的前面几天也要排除，这个在编程中，已经自动根据开学日，来确定是开学这一周的第几天，然后把前面几天加到节日的数组中去了。这一段的代码，见
# 排除开学日这一周中，开学日前的日期

5 还必须要计算的一样东西，是一周中的每节课之间的日期差，比如第一节到第二节，这是一条线，第二节到第三节，这是第二条线，最后一节到下一周的第一节，这是最后一条线。日期差也会形成新的条线。这一段的代码见
# 计算固定的日期差

6 当上课日期遇上节日，比如三（5）班，当周一遇上节日，那么就要把这节课的日期，加上与第二节课的日期差，于是，这节课变成在第二条上课线上了，而原来第二节课，必须加上第二个日期差，那如果第三节课呢？就要加上第三个日期差，由此可以看出，每条上课线都要有一个变量，来保存原来在这条线上已经有的全部的日期差，这个变量的初始值，不分条线，都是零。然后，还要有一个变量，用来指向下一个日期差，是哪一条日期差线上的，并且这个变量的初始值，是随日期差而变，分别是 0，1，2 ... 。这一段的代码，见
# 先要初始化一下 @all_gaps

7 然后，开始根据课题安排的数组 @weeks_grades_subjects ，逐行的读取某一课，在第几周，第几条线上课，计算出日期 $cur_day ，然后先加上原来所有的日期差的和，因为每条线上的日期差的和，都是不一样的，所以 $cur_class_in_week_turn 非常关键，就是它指出了这节课，是在哪条上课线上的，因此，正确的日期差的和会加到原来的日期上。然后，开始判断是否在节日中，如果不在，那么看是不是遇上的交换节假日，然后保存结果到数组。
如果遇上节假日，那么就要根据指向日期差的线，加上相应的日期差，这里 $cur_gap = $point_2_gap_of_week[$cur_grade][$cur_class][$cur_class_in_week_turn]; 指出了就目前这条线，日期差到底是哪一条，刚才说 三（5）班，周一的课，当遇上第一次日期变轨时，选的日期差是周一到周三的，然后它会 +1 ，如果到最后就重置为 0 ，这样，下一次遇上变轨时，因为它指向的是下一个日期差，就不是周一到周三的，而是周三到周一的了。当前日期当然只加一次日期差，而总的日期差，也得加上这个日期差。
  因为有个 $in_hdays 的变量，只要在日期变轨中运行过，就置为 1 ，只有从来没有遇到过节日，才为零，所以确保了不会遗漏节日。这段代码见
# 测试程序

8 最后还要对结果进行排序，但是 print 到文件的话，会把空格吃掉，很烦，所以是用重定向来输出结果。

9 安装 ChineseNumbersU8 时，还要安装 Lingua::EN::Numbers 模块